/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/spotifynt.js":
/*!***********************************!*\
  !*** ./resources/js/spotifynt.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fast_average_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-average-color */ \"./node_modules/fast-average-color/dist/index.esm.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function (_e2) { function e(_x) { return _e2.apply(this, arguments); } e.toString = function () { return _e2.toString(); }; return e; }(function (e) { throw e; }), f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function (_e3) { function e(_x2) { return _e3.apply(this, arguments); } e.toString = function () { return _e3.toString(); }; return e; }(function (e) { didErr = true; err = e; }), f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\nwindow.Lists = new function () {\n  this.store = function (list, items) {\n    sessionStorage.setItem('list-' + list, JSON.stringify(items));\n  };\n\n  this.clear = function (list) {\n    sessionStorage.setItem('list-' + list, JSON.stringify([]));\n  };\n\n  this.appendOrStore = function (list, items) {\n    if (Lists.get(list)) {\n      Lists.append(list, items);\n    } else {\n      Lists.store(list, items);\n    }\n  };\n\n  this.removeDuplicates = function (list) {\n    var items = Lists.get(list);\n    items = items.reduce(function (a, b) {\n      if (a.indexOf(b) < 0) a.push(b);\n      return a;\n    }, []);\n    Lists.store(list, items);\n  };\n\n  this.append = function (list, songs) {\n    var items = Lists.get(list);\n    items = items.concat(songs);\n    sessionStorage.setItem('list-' + list, JSON.stringify(items));\n  };\n\n  this.merge = function (lista, listb) {\n    var itemsa = Lists.get(lista);\n    var itemsb = Lists.get(listb);\n    itemsa = itemsa.concat(itemsb);\n    sessionStorage.setItem('list-' + lista, JSON.stringify(itemsa));\n  };\n\n  this.shuffle = function (list) {\n    var items = JSON.parse(sessionStorage.getItem('list-' + list));\n\n    for (var i = items.length - 1; i > 0; i--) {\n      var j = Math.floor(Math.random() * (i + 1));\n      var temp = items[i];\n      items[i] = items[j];\n      items[j] = temp;\n    }\n\n    sessionStorage.setItem('list-' + list, JSON.stringify(items));\n    return this;\n  };\n\n  this.get = function (list) {\n    try {\n      return JSON.parse(sessionStorage.getItem('list-' + list));\n    } catch (_unused) {\n      return false;\n    }\n  };\n}();\nwindow.Spotifynt = new function () {\n  var port = \"8337\";\n  var url = \"http://localhost\";\n  this.player = new function () {\n    this.show = function (song) {\n      document.querySelector(\"#audio-player\").src = Spotifynt.command.fileUrl(song.id);\n      document.querySelector(\"#text-songTitle\").textContent = song.title;\n      document.querySelector(\"#text-songArtist\").textContent = song.artist;\n      document.querySelector(\"#img-songArt\").src = Spotifynt.command.artUrl(song.album_id);\n      document.querySelector(\"#row-player\").hidden = false;\n      Spotifynt.metadata.set(song, Spotifynt.command.artUrl(song.album_id));\n      Spotifynt.displayPlayer(true);\n      var fac = new fast_average_color__WEBPACK_IMPORTED_MODULE_0__.default();\n      fac.getColorAsync(document.querySelector(\"#img-songArt\").src).then(function (color) {\n        document.querySelector(\"#app\").style.backgroundColor = color.hex + \"99\";\n        document.querySelector(\"meta[name='theme-color'\").content = color.hex;\n      })[\"catch\"](function (e) {\n        return console.log(e);\n      });\n    };\n  }();\n  this.playlist = new function () {\n    function get() {\n      var playlist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"playlist-actual\";\n      return Lists.get(playlist);\n    }\n\n    this[\"new\"] = function (playlist, songs) {\n      var items = [];\n\n      var _iterator = _createForOfIteratorHelper(songs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var song = _step.value;\n          items.push(song.id);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      Lists.clear(playlist);\n      Lists.store(playlist, items);\n      Lists.removeDuplicates(playlist);\n      return this;\n    };\n\n    this.load = function (songs) {\n      var random = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var playlist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"playlist-actual\";\n\n      if (random) {\n        Lists.shuffle(songs);\n      }\n\n      Lists.appendOrStore(playlist, get(songs));\n      Lists.removeDuplicates(playlist);\n      return this;\n    };\n\n    this.clear = function () {\n      var playlist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"playlist-actual\";\n      Lists.clear(playlist);\n      return this;\n    };\n\n    this.play = function () {\n      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var playlist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"playlist-actual\";\n\n      if (i === false) {\n        i = parseInt(sessionStorage.getItem(\"playlist-actual-i\"));\n      }\n\n      sessionStorage.setItem(\"playlist-actual-i\", i);\n      Spotifynt.command.item(get(playlist)[i]).then(function (song) {\n        Spotifynt.player.show(song);\n        Spotifynt.player_playpause(\"play\");\n      });\n    };\n\n    this.move = function (i) {\n      var playlist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"playlist-actual\";\n      var length = get(playlist).length;\n      var actual = parseInt(sessionStorage.getItem(\"playlist-actual-i\"));\n      var nuevo = ((actual + i) % length + length) % length;\n      sessionStorage.setItem(\"playlist-actual-i\", nuevo);\n      return this;\n    };\n  }();\n  this.metadata = new function () {\n    this.set = function (item, image) {\n      navigator.mediaSession.metadata = new MediaMetadata({\n        title: item.title,\n        artist: item.artist,\n        album: item.album,\n        artwork: [{\n          src: image,\n          sizes: '512x512',\n          type: 'image/png'\n        }]\n      });\n    };\n  }();\n  this.command = new function () {\n    this.getAlbumSongs = function (id) {\n      return command(\"album/\".concat(id, \"?expand\"));\n    };\n\n    this.item = function (id) {\n      return command(\"item/\".concat(id));\n    };\n\n    this.querySong = function (query) {\n      return command(\"item/query/\".concat(query));\n    };\n\n    this.queryAlbum = function (query) {\n      return command(\"album/query/\".concat(query));\n    };\n\n    this.artUrl = function (id) {\n      return \"\".concat(url, \":\").concat(port, \"/album/\").concat(id, \"/art\");\n    };\n\n    this.fileUrl = function (id) {\n      return \"\".concat(url, \":\").concat(port, \"/item/\").concat(id, \"/file\");\n    };\n\n    function command(arg) {\n      return fetch(\"\".concat(url, \":\").concat(port, \"/\").concat(arg), {\n        method: 'GET'\n      }).then(function (response) {\n        return response.json();\n      });\n    }\n  }();\n\n  this.search = function (query) {\n    this.command.querySong(query).then(function (response) {\n      var results = response.results;\n      show_songs(results, 'search');\n      Spotifynt.playlist[\"new\"]('search', results);\n    })[\"catch\"](function (err) {\n      return console.error(err);\n    });\n    this.command.queryAlbum(query).then(function (response) {\n      var results = response.results;\n      show_albums(results);\n    })[\"catch\"](function (err) {\n      return console.error(err);\n    });\n  };\n\n  this.show_info = function () {\n    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var list = sessionStorage.getItem(\"list_showing\");\n    var song_id = JSON.parse(sessionStorage.getItem(\"list-\".concat(list)))[item];\n    beet_getItem(song_id).then(function (song) {\n      document.querySelector(\"#modal-infoBody\").innerHTML = \"\";\n\n      for (e in song) {\n        p = document.createElement(\"p\");\n        p.innerHTML = \"<b>\".concat(e, \"</b>: \").concat(song[e]);\n        document.querySelector(\"#modal-infoBody\").appendChild(p);\n      }\n\n      document.querySelector(\"#modal-infoTitle\").textContent = song.title;\n      $('#modal-info').modal('show');\n    });\n  };\n\n  this.getAlbumSongs = function (id) {\n    return Spotifynt.command.getAlbumSongs(id);\n  };\n\n  function show_albums(albums) {\n    var l = document.querySelector(\"#div-albumResults\");\n    l.innerHTML = \"\";\n\n    var _iterator2 = _createForOfIteratorHelper(albums.entries()),\n        _step2;\n\n    try {\n      var _loop = function _loop() {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            i = _step2$value[0],\n            album = _step2$value[1];\n\n        var t = document.querySelector(\"#template-albumResult\").cloneNode(true).content;\n        t.querySelector(\"[data-album='title']\").textContent = \"\".concat(album.album);\n        t.querySelector(\"[data-album='artist']\").textContent = \"\".concat(album.albumartist);\n        t.querySelector(\"[data-album='art']\").src = Spotifynt.command.artUrl(album.id);\n        t.querySelector(\"[data-album='append']\").addEventListener(\"click\", function () {\n          Spotifynt.getAlbumSongs(album.id).then(function (songs) {\n            return Spotifynt.playlist[\"new\"](\"album-\".concat(album.id), songs.items).load(\"album-\".concat(album.id));\n          });\n        });\n        t.querySelector(\"[data-album='play']\").addEventListener(\"click\", function () {\n          Spotifynt.getAlbumSongs(album.id).then(function (songs) {\n            Spotifynt.playlist[\"new\"](\"album-\".concat(album.id), songs.items).clear().load(\"album-\".concat(album.id)).play(0);\n          });\n        }); //t.querySelector(\".list-song-info\").onclick = () => show_info(i);\n        //if (song.format === \"FLAC\"){\n        //t.querySelector(\".list-song-title\").classList.add('mdi')\n        //t.querySelector(\".list-song-title\").classList.add('mdi-quality-high')\n        //}\n\n        l.appendChild(t);\n      };\n\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    Spotifynt.displayAlbumResults(true);\n  }\n\n  function show_songs(songs, list) {\n    sessionStorage.setItem(\"list_showing\", list); //document.querySelector(\"#row-songResults\").hidden = false;\n\n    var l = document.querySelector(\"#div-songResults\");\n    l.innerHTML = \"\";\n\n    var _iterator3 = _createForOfIteratorHelper(songs.entries()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _slicedToArray(_step3.value, 2),\n            i = _step3$value[0],\n            song = _step3$value[1];\n\n        var t = document.querySelector(\"#template-songResult\").cloneNode(true).content;\n        t.querySelector(\"[data-song='title']\").textContent = \"\".concat(song.title);\n        t.querySelector(\"[data-song='artist']\").textContent = \"\".concat(song.artist); //t.querySelector(\".list-song-album\").textContent = `${song.album}`\n        //t.querySelector(\".list-song-play\").onclick = () => btn_play(i);\n        //t.querySelector(\".list-song-info\").onclick = () => show_info(i);\n        //if (song.format === \"FLAC\"){\n        //t.querySelector(\".list-song-title\").classList.add('mdi')\n        //t.querySelector(\".list-song-title\").classList.add('mdi-quality-high')\n        //}\n\n        l.appendChild(t);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    Spotifynt.displaySongResults(true);\n  }\n\n  this.btn_play = function (i) {\n    var list = sessionStorage.getItem(\"list_showing\");\n    list.clear('playlist');\n    list.merge('playlist', list);\n    playlist_play(i);\n  };\n\n  this.player_playpause = function () {\n    var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var player = document.querySelector(\"#audio-player\");\n\n    if (player.paused || action === \"play\") {\n      sessionStorage.setItem(\"player_playing\", 'playing');\n      document.querySelector(\"#icon-pause\").hidden = false;\n      document.querySelector(\"#icon-play\").hidden = true;\n      player.play();\n    } else if (!player.paused || action === \"pause\") {\n      sessionStorage.setItem(\"player_playing\", 'paused');\n      document.querySelector(\"#icon-play\").hidden = false;\n      document.querySelector(\"#icon-pause\").hidden = true;\n      player.pause();\n    }\n  };\n\n  this.displaySongResults = function (e) {\n    document.querySelector(\"#row-songResults\").hidden = !e;\n  };\n\n  this.displayAlbumResults = function (e) {\n    document.querySelector(\"#row-albumResults\").hidden = !e;\n  };\n\n  this.displayPlayer = function (e) {\n    document.querySelector(\"#row-player\").hidden = !e;\n  };\n}();\nnavigator.mediaSession.setActionHandler('play', function () {\n  return Spotifynt.player_playpause('play');\n});\nnavigator.mediaSession.setActionHandler('pause', function () {\n  return Spotifynt.player_playpause('pause');\n});\nnavigator.mediaSession.setActionHandler('previoustrack', function () {\n  return Spotifynt.playlist.move(-1).play();\n});\nnavigator.mediaSession.setActionHandler('nexttrack', function () {\n  return Spotifynt.playlist.move(1).play();\n});\ndocument.querySelector('#input-search').addEventListener('change', function (e) {\n  return Spotifynt.search(e.target.value);\n});\ndocument.querySelector(\"#audio-player\").addEventListener('ended', function () {\n  return Spotifynt.playlist.move(1).play();\n});\ndocument.querySelector(\"#btn-nextSong\").addEventListener('click', function () {\n  return Spotifynt.playlist.move(1).play();\n});\ndocument.querySelector(\"#btn-prevSong\").addEventListener('click', function () {\n  return Spotifynt.playlist.move(-1).play();\n});\ndocument.querySelector(\"#btn-playpause\").addEventListener('click', function () {\n  return Spotifynt.player_playpause();\n});\ndocument.querySelector(\"#btn-playPlaylist\").addEventListener('click', function () {\n  Spotifynt.playlist.clear().load(\"search\", true).play(0);\n});\ndocument.querySelector(\"#btn-appendPlaylist\").addEventListener('click', function () {\n  Spotifynt.playlist.load(\"search\");\n});\nwindow.addEventListener('beforeunload', function (e) {\n  e.preventDefault();\n  e.returnValue = '';\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxJQUFuQixDQUF3QixDQUF4QixFQUEyQkosSUFBM0IsRUFBTjtBQUFBLENBQWxFO0FBQ0E1QixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsZUFBdkIsRUFBd0N3RSxnQkFBeEMsQ0FBeUQsT0FBekQsRUFBa0U7QUFBQSxTQUFNL0UsU0FBUyxDQUFDZ0MsUUFBVixDQUFtQk0sSUFBbkIsQ0FBd0IsQ0FBQyxDQUF6QixFQUE0QkosSUFBNUIsRUFBTjtBQUFBLENBQWxFO0FBQ0E1QixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsZ0JBQXZCLEVBQXlDd0UsZ0JBQXpDLENBQTBELE9BQTFELEVBQW1FO0FBQUEsU0FBTS9FLFNBQVMsQ0FBQ3FDLGdCQUFWLEVBQU47QUFBQSxDQUFuRTtBQUVBL0IsUUFBUSxDQUFDQyxhQUFULENBQXVCLG1CQUF2QixFQUE0Q3dFLGdCQUE1QyxDQUE2RCxPQUE3RCxFQUFzRSxZQUFNO0FBQzFFL0UsRUFBQUEsU0FBUyxDQUFDZ0MsUUFBVixDQUFtQjNELEtBQW5CLEdBQTJCNEQsSUFBM0IsQ0FBZ0MsUUFBaEMsRUFBMEMsSUFBMUMsRUFBZ0RDLElBQWhELENBQXFELENBQXJEO0FBQ0QsQ0FGRDtBQUlBNUIsUUFBUSxDQUFDQyxhQUFULENBQXVCLHFCQUF2QixFQUE4Q3dFLGdCQUE5QyxDQUErRCxPQUEvRCxFQUF3RSxZQUFNO0FBQzVFL0UsRUFBQUEsU0FBUyxDQUFDZ0MsUUFBVixDQUFtQkMsSUFBbkIsQ0FBd0IsUUFBeEI7QUFDRCxDQUZEO0FBSUFyRSxNQUFNLENBQUNtSCxnQkFBUCxDQUF3QixjQUF4QixFQUF3QyxVQUFBbEQsQ0FBQyxFQUFJO0FBQzNDQSxFQUFBQSxDQUFDLENBQUM2RCxjQUFGO0FBQ0E3RCxFQUFBQSxDQUFDLENBQUM4RCxXQUFGLEdBQWdCLEVBQWhCO0FBQ0QsQ0FIRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9zcG90aWZ5bnQuanM/NTg5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRmFzdEF2ZXJhZ2VDb2xvciBmcm9tICdmYXN0LWF2ZXJhZ2UtY29sb3InO1xuXG53aW5kb3cuTGlzdHMgPSBuZXcgKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0b3JlID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKXtcblxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnbGlzdC0nK2xpc3QsIEpTT04uc3RyaW5naWZ5KGl0ZW1zKSlcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKGxpc3Qpe1xuXG4gICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdsaXN0LScrbGlzdCwgSlNPTi5zdHJpbmdpZnkoW10pKVxuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kT3JTdG9yZSA9IGZ1bmN0aW9uIChsaXN0LCBpdGVtcyl7XG4gICAgICBpZiAoTGlzdHMuZ2V0KGxpc3QpKXtcbiAgICAgICAgTGlzdHMuYXBwZW5kKGxpc3QsIGl0ZW1zKVxuICAgICAgfWVsc2V7XG5cbiAgICAgICAgTGlzdHMuc3RvcmUobGlzdCwgaXRlbXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24obGlzdCl7XG4gICAgICBsZXQgaXRlbXMgPSBMaXN0cy5nZXQobGlzdClcbiAgICAgIGl0ZW1zID0gaXRlbXMucmVkdWNlKGZ1bmN0aW9uKGEsYil7aWYoYS5pbmRleE9mKGIpPDApYS5wdXNoKGIpO3JldHVybiBhO30sW10pO1xuICAgICAgTGlzdHMuc3RvcmUobGlzdCwgaXRlbXMpXG5cbiAgICB9XG5cbiAgICB0aGlzLmFwcGVuZCA9IGZ1bmN0aW9uIChsaXN0LCBzb25ncyl7XG4gICAgICBsZXQgaXRlbXMgPSBMaXN0cy5nZXQobGlzdClcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KHNvbmdzKVxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnbGlzdC0nK2xpc3QsIEpTT04uc3RyaW5naWZ5KGl0ZW1zKSlcbiAgICB9XG5cbiAgICB0aGlzLm1lcmdlID0gZnVuY3Rpb24gKGxpc3RhLCBsaXN0Yil7XG4gICAgICBsZXQgaXRlbXNhID0gTGlzdHMuZ2V0KGxpc3RhKVxuICAgICAgbGV0IGl0ZW1zYiA9IExpc3RzLmdldChsaXN0YilcbiAgICAgIGl0ZW1zYSA9IGl0ZW1zYS5jb25jYXQoaXRlbXNiKVxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnbGlzdC0nK2xpc3RhLCBKU09OLnN0cmluZ2lmeShpdGVtc2EpKVxuICAgIH1cblxuICAgIHRoaXMuc2h1ZmZsZSA9IGZ1bmN0aW9uIChsaXN0KXtcbiAgICAgIGxldCBpdGVtcyA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnbGlzdC0nK2xpc3QpKVxuXG4gICAgICBmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgIGxldCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgICAgbGV0IHRlbXAgPSBpdGVtc1tpXTtcbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2pdO1xuICAgICAgICAgIGl0ZW1zW2pdID0gdGVtcDtcbiAgICAgIH1cblxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnbGlzdC0nK2xpc3QsIEpTT04uc3RyaW5naWZ5KGl0ZW1zKSlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKGxpc3Qpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnbGlzdC0nK2xpc3QpKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxud2luZG93LlNwb3RpZnludCA9IG5ldyAoZnVuY3Rpb24gKCkge1xuICBsZXQgcG9ydCA9IFwiODMzN1wiO1xuICBsZXQgdXJsID0gXCJodHRwOi8vbG9jYWxob3N0XCI7XG5cbiAgdGhpcy5wbGF5ZXIgPSBuZXcgKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNob3cgPSBmdW5jdGlvbihzb25nKXtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYXVkaW8tcGxheWVyXCIpLnNyYyA9IFNwb3RpZnludC5jb21tYW5kLmZpbGVVcmwoc29uZy5pZCk7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3RleHQtc29uZ1RpdGxlXCIpLnRleHRDb250ZW50ID0gc29uZy50aXRsZVxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0ZXh0LXNvbmdBcnRpc3RcIikudGV4dENvbnRlbnQgPSBzb25nLmFydGlzdFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbWctc29uZ0FydFwiKS5zcmMgPSAgU3BvdGlmeW50LmNvbW1hbmQuYXJ0VXJsKHNvbmcuYWxidW1faWQpXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Jvdy1wbGF5ZXJcIikuaGlkZGVuID0gZmFsc2U7XG5cbiAgICAgIFNwb3RpZnludC5tZXRhZGF0YS5zZXQoc29uZywgU3BvdGlmeW50LmNvbW1hbmQuYXJ0VXJsKHNvbmcuYWxidW1faWQpKVxuXG4gICAgICBTcG90aWZ5bnQuZGlzcGxheVBsYXllcih0cnVlKTtcblxuICAgICAgY29uc3QgZmFjID0gbmV3IEZhc3RBdmVyYWdlQ29sb3IoKTtcblxuICAgICAgZmFjLmdldENvbG9yQXN5bmMoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbWctc29uZ0FydFwiKS5zcmMpXG4gICAgICAgICAgLnRoZW4oY29sb3IgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNhcHBcIikuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3IuaGV4ICsgXCI5OVwiXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPSd0aGVtZS1jb2xvcidcIikuY29udGVudCA9IGNvbG9yLmhleDtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlID0+IGNvbnNvbGUubG9nKGUpKTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5wbGF5bGlzdCA9IG5ldyhmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBnZXQocGxheWxpc3Q9XCJwbGF5bGlzdC1hY3R1YWxcIikge1xuICAgICAgcmV0dXJuIExpc3RzLmdldChwbGF5bGlzdCk7XG4gICAgfVxuICAgIHRoaXMubmV3ID0gZnVuY3Rpb24ocGxheWxpc3QsIHNvbmdzKXtcbiAgICAgIGxldCBpdGVtcyA9IFtdXG4gICAgICBmb3IgKGxldCBzb25nIG9mIHNvbmdzKXtcbiAgICAgICAgaXRlbXMucHVzaChzb25nLmlkKVxuICAgICAgfVxuICAgICAgTGlzdHMuY2xlYXIocGxheWxpc3QpXG4gICAgICBMaXN0cy5zdG9yZShwbGF5bGlzdCwgaXRlbXMpXG4gICAgICBMaXN0cy5yZW1vdmVEdXBsaWNhdGVzKHBsYXlsaXN0KVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5sb2FkID0gZnVuY3Rpb24oc29uZ3MsIHJhbmRvbT1mYWxzZSwgcGxheWxpc3Q9XCJwbGF5bGlzdC1hY3R1YWxcIikge1xuICAgICAgaWYocmFuZG9tKXtcbiAgICAgICAgTGlzdHMuc2h1ZmZsZShzb25ncyk7XG4gICAgICB9XG4gICAgICBMaXN0cy5hcHBlbmRPclN0b3JlKHBsYXlsaXN0LCBnZXQoc29uZ3MpKTtcbiAgICAgIExpc3RzLnJlbW92ZUR1cGxpY2F0ZXMocGxheWxpc3QpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24ocGxheWxpc3Q9XCJwbGF5bGlzdC1hY3R1YWxcIikge1xuICAgICAgTGlzdHMuY2xlYXIocGxheWxpc3QpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLnBsYXkgPSBmdW5jdGlvbihpPWZhbHNlLCBwbGF5bGlzdD1cInBsYXlsaXN0LWFjdHVhbFwiKSB7XG4gICAgICBpZiAoaSA9PT0gZmFsc2Upe1xuICAgICAgICBpID0gcGFyc2VJbnQoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcInBsYXlsaXN0LWFjdHVhbC1pXCIpKTtcbiAgICAgIH1cbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJwbGF5bGlzdC1hY3R1YWwtaVwiLCBpKTtcbiAgICAgIFNwb3RpZnludC5jb21tYW5kLml0ZW0oZ2V0KHBsYXlsaXN0KVtpXSlcbiAgICAgICAgLnRoZW4oc29uZyA9PiB7XG4gICAgICAgICAgU3BvdGlmeW50LnBsYXllci5zaG93KHNvbmcpXG4gICAgICAgICAgU3BvdGlmeW50LnBsYXllcl9wbGF5cGF1c2UoXCJwbGF5XCIpO1xuICAgICAgICB9KVxuXG4gICAgfVxuXG4gICAgdGhpcy5tb3ZlID0gZnVuY3Rpb24oaSwgcGxheWxpc3Q9XCJwbGF5bGlzdC1hY3R1YWxcIikge1xuICAgICAgbGV0IGxlbmd0aCA9IGdldChwbGF5bGlzdCkubGVuZ3RoO1xuICAgICAgbGV0IGFjdHVhbCA9IHBhcnNlSW50KHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJwbGF5bGlzdC1hY3R1YWwtaVwiKSk7XG4gICAgICBsZXQgbnVldm8gPSAoKChhY3R1YWwgKyBpKSAlIGxlbmd0aCkgKyBsZW5ndGgpICUgbGVuZ3RoO1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcInBsYXlsaXN0LWFjdHVhbC1pXCIsIG51ZXZvKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH0pXG5cbiAgdGhpcy5tZXRhZGF0YSA9IG5ldyAoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24gKGl0ZW0sIGltYWdlKXtcbiAgICAgIG5hdmlnYXRvci5tZWRpYVNlc3Npb24ubWV0YWRhdGEgPSBuZXcgTWVkaWFNZXRhZGF0YSh7XG4gICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxuICAgICAgICBhcnRpc3Q6IGl0ZW0uYXJ0aXN0LFxuICAgICAgICBhbGJ1bTogaXRlbS5hbGJ1bSxcbiAgICAgICAgYXJ0d29yazogW1xuICAgICAgICAgIHsgc3JjOiBpbWFnZSwgc2l6ZXM6ICc1MTJ4NTEyJywgdHlwZTogJ2ltYWdlL3BuZycgfSxcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmNvbW1hbmQgPSBuZXcgKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdldEFsYnVtU29uZ3MgPSBmdW5jdGlvbiAoaWQpe1xuXG4gICAgICByZXR1cm4gY29tbWFuZChgYWxidW0vJHtpZH0/ZXhwYW5kYClcbiAgICB9XG5cbiAgICB0aGlzLml0ZW0gPSBmdW5jdGlvbiAoaWQpe1xuXG4gICAgICByZXR1cm4gY29tbWFuZChgaXRlbS8ke2lkfWApXG4gICAgfVxuXG4gICAgdGhpcy5xdWVyeVNvbmcgPSBmdW5jdGlvbiAocXVlcnkpe1xuXG4gICAgICByZXR1cm4gY29tbWFuZChgaXRlbS9xdWVyeS8ke3F1ZXJ5fWApXG4gICAgfVxuXG4gICAgdGhpcy5xdWVyeUFsYnVtID0gZnVuY3Rpb24gKHF1ZXJ5KXtcblxuICAgICAgcmV0dXJuIGNvbW1hbmQoYGFsYnVtL3F1ZXJ5LyR7cXVlcnl9YClcbiAgICB9XG5cbiAgICB0aGlzLmFydFVybCA9IGZ1bmN0aW9uIChpZCl7XG5cbiAgICAgIHJldHVybiBgJHt1cmx9OiR7cG9ydH0vYWxidW0vJHtpZH0vYXJ0YFxuICAgIH1cblxuICAgIHRoaXMuZmlsZVVybCA9IGZ1bmN0aW9uIChpZCl7XG5cbiAgICAgIHJldHVybiBgJHt1cmx9OiR7cG9ydH0vaXRlbS8ke2lkfS9maWxlYFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbW1hbmQoYXJnKXtcbiAgICAgIHJldHVybiBmZXRjaChgJHt1cmx9OiR7cG9ydH0vJHthcmd9YCwge21ldGhvZDogJ0dFVCd9KVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgfVxuICB9KTtcblxuICB0aGlzLnNlYXJjaCA9IGZ1bmN0aW9uIChxdWVyeSl7XG4gICAgdGhpcy5jb21tYW5kLnF1ZXJ5U29uZyhxdWVyeSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSByZXNwb25zZS5yZXN1bHRzXG4gICAgICAgIHNob3dfc29uZ3MocmVzdWx0cywgJ3NlYXJjaCcpXG4gICAgICAgIFNwb3RpZnludC5wbGF5bGlzdC5uZXcoJ3NlYXJjaCcsIHJlc3VsdHMpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpXG5cbiAgICB0aGlzLmNvbW1hbmQucXVlcnlBbGJ1bShxdWVyeSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSByZXNwb25zZS5yZXN1bHRzXG4gICAgICAgIHNob3dfYWxidW1zKHJlc3VsdHMpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpXG4gIH1cblxuICB0aGlzLnNob3dfaW5mbyA9IGZ1bmN0aW9uIChpdGVtPTApe1xuICAgIGxldCBsaXN0ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcImxpc3Rfc2hvd2luZ1wiKVxuICAgIGxldCBzb25nX2lkID0gSlNPTi5wYXJzZShzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGBsaXN0LSR7bGlzdH1gKSlbaXRlbV1cblxuICAgIGJlZXRfZ2V0SXRlbShzb25nX2lkKVxuICAgIC50aGVuKHNvbmcgPT4ge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNtb2RhbC1pbmZvQm9keVwiKS5pbm5lckhUTUwgPSBcIlwiXG4gICAgICBmb3IgKGUgaW4gc29uZykge1xuICAgICAgICBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIilcbiAgICAgICAgcC5pbm5lckhUTUwgPSBgPGI+JHtlfTwvYj46ICR7c29uZ1tlXX1gXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbW9kYWwtaW5mb0JvZHlcIikuYXBwZW5kQ2hpbGQocClcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbW9kYWwtaW5mb1RpdGxlXCIpLnRleHRDb250ZW50ID0gc29uZy50aXRsZVxuXG4gICAgICAkKCcjbW9kYWwtaW5mbycpLm1vZGFsKCdzaG93JylcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5nZXRBbGJ1bVNvbmdzID0gZnVuY3Rpb24gKGlkKXtcbiAgICByZXR1cm4gU3BvdGlmeW50LmNvbW1hbmQuZ2V0QWxidW1Tb25ncyhpZCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNob3dfYWxidW1zKGFsYnVtcykge1xuICAgIGxldCBsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNkaXYtYWxidW1SZXN1bHRzXCIpO1xuICAgIGwuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgIGZvciAoY29uc3QgW2ksIGFsYnVtXSBvZiBhbGJ1bXMuZW50cmllcygpKXtcbiAgICAgIGxldCB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0ZW1wbGF0ZS1hbGJ1bVJlc3VsdFwiKS5jbG9uZU5vZGUodHJ1ZSkuY29udGVudDtcblxuICAgICAgdC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtYWxidW09J3RpdGxlJ11cIikudGV4dENvbnRlbnQgPSBgJHthbGJ1bS5hbGJ1bX1gXG4gICAgICB0LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1hbGJ1bT0nYXJ0aXN0J11cIikudGV4dENvbnRlbnQgPSBgJHthbGJ1bS5hbGJ1bWFydGlzdH1gXG4gICAgICB0LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1hbGJ1bT0nYXJ0J11cIikuc3JjID0gU3BvdGlmeW50LmNvbW1hbmQuYXJ0VXJsKGFsYnVtLmlkKVxuICAgICAgdC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtYWxidW09J2FwcGVuZCddXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgIFNwb3RpZnludC5nZXRBbGJ1bVNvbmdzKGFsYnVtLmlkKVxuICAgICAgICAudGhlbihzb25ncyA9PiBTcG90aWZ5bnQucGxheWxpc3QubmV3KGBhbGJ1bS0ke2FsYnVtLmlkfWAsIHNvbmdzLml0ZW1zKS5sb2FkKGBhbGJ1bS0ke2FsYnVtLmlkfWApKVxuICAgICAgfSlcbiAgICAgIHQucXVlcnlTZWxlY3RvcihcIltkYXRhLWFsYnVtPSdwbGF5J11cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcblxuICAgICAgICBTcG90aWZ5bnQuZ2V0QWxidW1Tb25ncyhhbGJ1bS5pZClcbiAgICAgICAgLnRoZW4oc29uZ3MgPT4ge1xuICAgICAgICAgIFNwb3RpZnludC5wbGF5bGlzdC5uZXcoYGFsYnVtLSR7YWxidW0uaWR9YCwgc29uZ3MuaXRlbXMpLmNsZWFyKCkubG9hZChgYWxidW0tJHthbGJ1bS5pZH1gKS5wbGF5KDApXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgLy90LnF1ZXJ5U2VsZWN0b3IoXCIubGlzdC1zb25nLWluZm9cIikub25jbGljayA9ICgpID0+IHNob3dfaW5mbyhpKTtcblxuICAgICAgLy9pZiAoc29uZy5mb3JtYXQgPT09IFwiRkxBQ1wiKXtcbiAgICAgICAgLy90LnF1ZXJ5U2VsZWN0b3IoXCIubGlzdC1zb25nLXRpdGxlXCIpLmNsYXNzTGlzdC5hZGQoJ21kaScpXG4gICAgICAgIC8vdC5xdWVyeVNlbGVjdG9yKFwiLmxpc3Qtc29uZy10aXRsZVwiKS5jbGFzc0xpc3QuYWRkKCdtZGktcXVhbGl0eS1oaWdoJylcbiAgICAgIC8vfVxuXG4gICAgICBsLmFwcGVuZENoaWxkKHQpO1xuXG4gICAgfVxuICAgIFNwb3RpZnludC5kaXNwbGF5QWxidW1SZXN1bHRzKHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvd19zb25ncyhzb25ncywgbGlzdCl7XG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcImxpc3Rfc2hvd2luZ1wiLCBsaXN0KTtcbiAgICAvL2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcm93LXNvbmdSZXN1bHRzXCIpLmhpZGRlbiA9IGZhbHNlO1xuICAgIGxldCBsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNkaXYtc29uZ1Jlc3VsdHNcIik7XG4gICAgbC5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgZm9yIChjb25zdCBbaSwgc29uZ10gb2Ygc29uZ3MuZW50cmllcygpKXtcbiAgICAgIGxldCB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0ZW1wbGF0ZS1zb25nUmVzdWx0XCIpLmNsb25lTm9kZSh0cnVlKS5jb250ZW50O1xuXG4gICAgICB0LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1zb25nPSd0aXRsZSddXCIpLnRleHRDb250ZW50ID0gYCR7c29uZy50aXRsZX1gXG4gICAgICB0LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1zb25nPSdhcnRpc3QnXVwiKS50ZXh0Q29udGVudCA9IGAke3NvbmcuYXJ0aXN0fWBcbiAgICAgIC8vdC5xdWVyeVNlbGVjdG9yKFwiLmxpc3Qtc29uZy1hbGJ1bVwiKS50ZXh0Q29udGVudCA9IGAke3NvbmcuYWxidW19YFxuICAgICAgLy90LnF1ZXJ5U2VsZWN0b3IoXCIubGlzdC1zb25nLXBsYXlcIikub25jbGljayA9ICgpID0+IGJ0bl9wbGF5KGkpO1xuICAgICAgLy90LnF1ZXJ5U2VsZWN0b3IoXCIubGlzdC1zb25nLWluZm9cIikub25jbGljayA9ICgpID0+IHNob3dfaW5mbyhpKTtcblxuICAgICAgLy9pZiAoc29uZy5mb3JtYXQgPT09IFwiRkxBQ1wiKXtcbiAgICAgICAgLy90LnF1ZXJ5U2VsZWN0b3IoXCIubGlzdC1zb25nLXRpdGxlXCIpLmNsYXNzTGlzdC5hZGQoJ21kaScpXG4gICAgICAgIC8vdC5xdWVyeVNlbGVjdG9yKFwiLmxpc3Qtc29uZy10aXRsZVwiKS5jbGFzc0xpc3QuYWRkKCdtZGktcXVhbGl0eS1oaWdoJylcbiAgICAgIC8vfVxuXG4gICAgICBsLmFwcGVuZENoaWxkKHQpO1xuXG4gICAgfVxuXG4gICAgU3BvdGlmeW50LmRpc3BsYXlTb25nUmVzdWx0cyh0cnVlKTtcbiAgfVxuXG5cbiAgdGhpcy5idG5fcGxheSA9IGZ1bmN0aW9uIChpKXtcbiAgICBsZXQgbGlzdCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJsaXN0X3Nob3dpbmdcIik7XG4gICAgbGlzdC5jbGVhcigncGxheWxpc3QnKVxuICAgIGxpc3QubWVyZ2UoJ3BsYXlsaXN0JywgbGlzdClcbiAgICBwbGF5bGlzdF9wbGF5KGkpXG4gIH1cblxuICB0aGlzLnBsYXllcl9wbGF5cGF1c2UgPSBmdW5jdGlvbiAoYWN0aW9uPVwiXCIpe1xuICAgIGxldCBwbGF5ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2F1ZGlvLXBsYXllclwiKTtcbiAgICBpZiAocGxheWVyLnBhdXNlZCB8fCBhY3Rpb24gPT09IFwicGxheVwiKXtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJwbGF5ZXJfcGxheWluZ1wiLCAncGxheWluZycpO1xuXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2ljb24tcGF1c2VcIikuaGlkZGVuID0gZmFsc2U7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2ljb24tcGxheVwiKS5oaWRkZW4gPSB0cnVlO1xuXG4gICAgICBwbGF5ZXIucGxheSgpXG5cbiAgICB9ZWxzZSBpZighcGxheWVyLnBhdXNlZCB8fCBhY3Rpb24gPT09IFwicGF1c2VcIil7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwicGxheWVyX3BsYXlpbmdcIiwgJ3BhdXNlZCcpO1xuXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2ljb24tcGxheVwiKS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjaWNvbi1wYXVzZVwiKS5oaWRkZW4gPSB0cnVlO1xuXG4gICAgICBwbGF5ZXIucGF1c2UoKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZGlzcGxheVNvbmdSZXN1bHRzID0gZnVuY3Rpb24gKGUpe1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcm93LXNvbmdSZXN1bHRzXCIpLmhpZGRlbiA9ICFlXG4gIH1cblxuICB0aGlzLmRpc3BsYXlBbGJ1bVJlc3VsdHMgPSBmdW5jdGlvbiAoZSl7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyb3ctYWxidW1SZXN1bHRzXCIpLmhpZGRlbiA9ICFlXG4gIH1cblxuICB0aGlzLmRpc3BsYXlQbGF5ZXIgPSBmdW5jdGlvbiAoZSl7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyb3ctcGxheWVyXCIpLmhpZGRlbiA9ICFlXG4gIH1cblxufSk7XG5cbm5hdmlnYXRvci5tZWRpYVNlc3Npb24uc2V0QWN0aW9uSGFuZGxlcigncGxheScsICgpID0+IFNwb3RpZnludC5wbGF5ZXJfcGxheXBhdXNlKCdwbGF5JykpO1xubmF2aWdhdG9yLm1lZGlhU2Vzc2lvbi5zZXRBY3Rpb25IYW5kbGVyKCdwYXVzZScsICgpID0+IFNwb3RpZnludC5wbGF5ZXJfcGxheXBhdXNlKCdwYXVzZScpKTtcbm5hdmlnYXRvci5tZWRpYVNlc3Npb24uc2V0QWN0aW9uSGFuZGxlcigncHJldmlvdXN0cmFjaycsICgpID0+IFNwb3RpZnludC5wbGF5bGlzdC5tb3ZlKC0xKS5wbGF5KCkpO1xubmF2aWdhdG9yLm1lZGlhU2Vzc2lvbi5zZXRBY3Rpb25IYW5kbGVyKCduZXh0dHJhY2snLCAoKSA9PiBTcG90aWZ5bnQucGxheWxpc3QubW92ZSgxKS5wbGF5KCkpO1xuXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5wdXQtc2VhcmNoJykuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiBTcG90aWZ5bnQuc2VhcmNoKGUudGFyZ2V0LnZhbHVlKSlcbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYXVkaW8tcGxheWVyXCIpLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgKCkgPT4gU3BvdGlmeW50LnBsYXlsaXN0Lm1vdmUoMSkucGxheSgpKVxuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNidG4tbmV4dFNvbmdcIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBTcG90aWZ5bnQucGxheWxpc3QubW92ZSgxKS5wbGF5KCkpXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2J0bi1wcmV2U29uZ1wiKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IFNwb3RpZnludC5wbGF5bGlzdC5tb3ZlKC0xKS5wbGF5KCkpXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2J0bi1wbGF5cGF1c2VcIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBTcG90aWZ5bnQucGxheWVyX3BsYXlwYXVzZSgpKVxuXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2J0bi1wbGF5UGxheWxpc3RcIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIFNwb3RpZnludC5wbGF5bGlzdC5jbGVhcigpLmxvYWQoXCJzZWFyY2hcIiwgdHJ1ZSkucGxheSgwKTtcbn0pXG5cbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYnRuLWFwcGVuZFBsYXlsaXN0XCIpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICBTcG90aWZ5bnQucGxheWxpc3QubG9hZChcInNlYXJjaFwiKVxufSlcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGUgPT4ge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUucmV0dXJuVmFsdWUgPSAnJztcbn0pO1xuIl0sIm5hbWVzIjpbIkZhc3RBdmVyYWdlQ29sb3IiLCJ3aW5kb3ciLCJMaXN0cyIsInN0b3JlIiwibGlzdCIsIml0ZW1zIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImNsZWFyIiwiYXBwZW5kT3JTdG9yZSIsImdldCIsImFwcGVuZCIsInJlbW92ZUR1cGxpY2F0ZXMiLCJyZWR1Y2UiLCJhIiwiYiIsImluZGV4T2YiLCJwdXNoIiwic29uZ3MiLCJjb25jYXQiLCJtZXJnZSIsImxpc3RhIiwibGlzdGIiLCJpdGVtc2EiLCJpdGVtc2IiLCJzaHVmZmxlIiwicGFyc2UiLCJnZXRJdGVtIiwiaSIsImxlbmd0aCIsImoiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0ZW1wIiwiU3BvdGlmeW50IiwicG9ydCIsInVybCIsInBsYXllciIsInNob3ciLCJzb25nIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwic3JjIiwiY29tbWFuZCIsImZpbGVVcmwiLCJpZCIsInRleHRDb250ZW50IiwidGl0bGUiLCJhcnRpc3QiLCJhcnRVcmwiLCJhbGJ1bV9pZCIsImhpZGRlbiIsIm1ldGFkYXRhIiwic2V0IiwiZGlzcGxheVBsYXllciIsImZhYyIsImdldENvbG9yQXN5bmMiLCJ0aGVuIiwiY29sb3IiLCJzdHlsZSIsImJhY2tncm91bmRDb2xvciIsImhleCIsImNvbnRlbnQiLCJlIiwiY29uc29sZSIsImxvZyIsInBsYXlsaXN0IiwibG9hZCIsInBsYXkiLCJwYXJzZUludCIsIml0ZW0iLCJwbGF5ZXJfcGxheXBhdXNlIiwibW92ZSIsImFjdHVhbCIsIm51ZXZvIiwiaW1hZ2UiLCJuYXZpZ2F0b3IiLCJtZWRpYVNlc3Npb24iLCJNZWRpYU1ldGFkYXRhIiwiYWxidW0iLCJhcnR3b3JrIiwic2l6ZXMiLCJ0eXBlIiwiZ2V0QWxidW1Tb25ncyIsInF1ZXJ5U29uZyIsInF1ZXJ5IiwicXVlcnlBbGJ1bSIsImFyZyIsImZldGNoIiwibWV0aG9kIiwicmVzcG9uc2UiLCJqc29uIiwic2VhcmNoIiwicmVzdWx0cyIsInNob3dfc29uZ3MiLCJlcnIiLCJlcnJvciIsInNob3dfYWxidW1zIiwic2hvd19pbmZvIiwic29uZ19pZCIsImJlZXRfZ2V0SXRlbSIsImlubmVySFRNTCIsInAiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCIkIiwibW9kYWwiLCJhbGJ1bXMiLCJsIiwiZW50cmllcyIsInQiLCJjbG9uZU5vZGUiLCJhbGJ1bWFydGlzdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNwbGF5QWxidW1SZXN1bHRzIiwiZGlzcGxheVNvbmdSZXN1bHRzIiwiYnRuX3BsYXkiLCJwbGF5bGlzdF9wbGF5IiwiYWN0aW9uIiwicGF1c2VkIiwicGF1c2UiLCJzZXRBY3Rpb25IYW5kbGVyIiwidGFyZ2V0IiwidmFsdWUiLCJwcmV2ZW50RGVmYXVsdCIsInJldHVyblZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/spotifynt.js\n");

/***/ }),

/***/ "./node_modules/fast-average-color/dist/index.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-average-color/dist/index.esm.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/*! Fast Average Color | © 2021 Denis Seleznev | MIT License | https://github.com/fast-average-color/fast-average-color */\nfunction toHex(num) {\n    const str = num.toString(16);\n\n    return str.length === 1 ? '0' + str : str;\n}\n\nfunction arrayToHex(arr) {\n    return '#' + arr.map(toHex).join('');\n}\n\nfunction isDark(color) {\n    // http://www.w3.org/TR/AERT#color-contrast\n    const result = (color[0] * 299 + color[1] * 587 + color[2] * 114) / 1000;\n\n    return result < 128;\n}\n\nfunction prepareIgnoredColor(color) {\n    if (!color) { return color; }\n\n    if (Array.isArray(color)) {\n        return typeof color[0] === 'number' ? [color.slice()] : color;\n    }\n\n    return [color];\n}\n\nfunction isIgnoredColor(data, index, ignoredColor) {\n    for (let i = 0; i < ignoredColor.length; i++) {\n        if (isIgnoredColorAsNumbers(data, index, ignoredColor[i])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction isIgnoredColorAsNumbers(data, index, ignoredColor) {\n    switch (ignoredColor.length) {\n        case 3:\n            // [red, green, blue]\n            if (isIgnoredRGBColor(data, index, ignoredColor)) {\n                return true;\n            }\n\n            break;\n        case 4:\n            // [red, green, blue, alpha]\n            if (isIgnoredRGBAColor(data, index, ignoredColor)) {\n                return true;\n            }\n\n            break;\n        case 5:\n            // [red, green, blue, alpha, threshold]\n            if (isIgnoredRGBAColorWithThreshold(data, index, ignoredColor)) {\n                return true;\n            }\n\n            break;\n        default:\n            return false;\n    }\n}\n\nfunction isIgnoredRGBColor(data, index, ignoredColor) {\n    // Ignore if the pixel are transparent.\n    if (data[index + 3] !== 255) {\n        return true;\n    }\n\n    if (data[index] === ignoredColor[0] &&\n        data[index + 1] === ignoredColor[1] &&\n        data[index + 2] === ignoredColor[2]\n    ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction isIgnoredRGBAColor(data, index, ignoredColor) {\n    if (data[index + 3] && ignoredColor[3]) {\n        return data[index] === ignoredColor[0] &&\n            data[index + 1] === ignoredColor[1] &&\n            data[index + 2] === ignoredColor[2] &&\n            data[index + 3] === ignoredColor[3];\n    }\n\n    // Ignore rgb components if the pixel are fully transparent.\n    return data[index + 3] === ignoredColor[3];\n}\n\nfunction inRange(colorComponent, ignoredColorComponent, value) {\n    return colorComponent >= (ignoredColorComponent - value) &&\n        colorComponent <= (ignoredColorComponent + value);\n}\n\nfunction isIgnoredRGBAColorWithThreshold(data, index, ignoredColor) {\n    const redIgnored = ignoredColor[0];\n    const greenIgnored = ignoredColor[1];\n    const blueIgnored = ignoredColor[2];\n    const alphaIgnored = ignoredColor[3];\n    const threshold = ignoredColor[4];\n    const alphaData = data[index + 3];\n\n    const alphaInRange = inRange(alphaData, alphaIgnored, threshold);\n    if (!alphaIgnored) {\n        return alphaInRange;\n    }\n\n    if (!alphaData && alphaInRange) {\n        return true;\n    }\n\n    if (inRange(data[index], redIgnored, threshold) &&\n        inRange(data[index + 1], greenIgnored, threshold) &&\n        inRange(data[index + 2], blueIgnored, threshold) &&\n        alphaInRange\n    ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction dominantAlgorithm(arr, len, options) {\n    const colorHash = {};\n    const divider = 24;\n    const ignoredColor = options.ignoredColor;\n    const step = options.step;\n    let max = [0, 0, 0, 0, 0];\n    \n    for (let i = 0; i < len; i += step) {\n        const red = arr[i];\n        const green = arr[i + 1];\n        const blue = arr[i + 2];\n        const alpha = arr[i + 3];\n\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n\n        const key = Math.round(red / divider) + ',' +\n                Math.round(green / divider) + ',' +\n                Math.round(blue / divider);\n\n        if (colorHash[key]) {\n            colorHash[key] = [\n                colorHash[key][0] + red * alpha,\n                colorHash[key][1] + green * alpha,\n                colorHash[key][2] + blue * alpha,\n                colorHash[key][3] + alpha,\n                colorHash[key][4] + 1\n            ];\n        } else {\n            colorHash[key] = [red * alpha, green * alpha, blue * alpha, alpha, 1];\n        }\n        \n        if (max[4] < colorHash[key][4]) {\n            max = colorHash[key];\n        }\n    }\n\n    const redTotal = max[0];\n    const greenTotal = max[1];\n    const blueTotal = max[2];\n\n    const alphaTotal = max[3];\n    const count = max[4];\n\n    return alphaTotal ? [\n        Math.round(redTotal / alphaTotal),\n        Math.round(greenTotal / alphaTotal),\n        Math.round(blueTotal / alphaTotal),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction simpleAlgorithm(arr, len, options) {\n    let redTotal = 0;\n    let greenTotal = 0;\n    let blueTotal = 0;\n    let alphaTotal = 0;\n    let count = 0;\n\n    const ignoredColor = options.ignoredColor;\n    const step = options.step;\n\n    for (let i = 0; i < len; i += step) {\n        const alpha = arr[i + 3];\n        const red = arr[i] * alpha;\n        const green = arr[i + 1] * alpha;\n        const blue = arr[i + 2] * alpha;\n\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n\n        redTotal += red;\n        greenTotal += green;\n        blueTotal += blue;\n        alphaTotal += alpha;\n\n        count++;\n    }\n\n    return alphaTotal ? [\n        Math.round(redTotal / alphaTotal),\n        Math.round(greenTotal / alphaTotal),\n        Math.round(blueTotal / alphaTotal),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction sqrtAlgorithm(arr, len, options) {\n    let redTotal = 0;\n    let greenTotal = 0;\n    let blueTotal = 0;\n    let alphaTotal = 0;\n    let count = 0;\n\n    const ignoredColor = options.ignoredColor;\n    const step = options.step;\n\n    for (let i = 0; i < len; i += step) {\n        const red = arr[i];\n        const green = arr[i + 1];\n        const blue = arr[i + 2];\n        const alpha = arr[i + 3];\n\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n\n        redTotal += red * red * alpha;\n        greenTotal += green * green * alpha;\n        blueTotal += blue * blue * alpha;\n        alphaTotal += alpha;\n\n        count++;\n    }\n\n    return alphaTotal ? [\n        Math.round(Math.sqrt(redTotal / alphaTotal)),\n        Math.round(Math.sqrt(greenTotal / alphaTotal)),\n        Math.round(Math.sqrt(blueTotal / alphaTotal)),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction getDefaultColor(options) {\n    return getOption(options, 'defaultColor', [0, 0, 0, 0]);\n}\n\nfunction getOption(options, name, defaultValue) {\n    return typeof options[name] === 'undefined' ? defaultValue : options[name];\n}\n\nconst MIN_SIZE = 10;\nconst MAX_SIZE = 100;\n\nfunction isSvg(filename) {\n    return filename.search(/\\.svg(\\?|$)/i) !== -1;\n}\n\nfunction getOriginalSize(resource) {\n    if (resource instanceof HTMLImageElement) {\n        let width = resource.naturalWidth;\n        let height = resource.naturalHeight;\n\n        // For SVG images with only viewBox attr.\n        if (!resource.naturalWidth && isSvg(resource.src)) {\n            width = height = MAX_SIZE;\n        }\n\n        return {\n            width,\n            height,\n        };\n    }\n\n    if (resource instanceof HTMLVideoElement) {\n        return {\n            width: resource.videoWidth,\n            height: resource.videoHeight\n        };\n    }\n\n    return {\n        width: resource.width,\n        height: resource.height\n    };\n}\n\nfunction prepareSizeAndPosition(originalSize, options) {\n    const srcLeft = getOption(options, 'left', 0);\n    const srcTop = getOption(options, 'top', 0);\n    const srcWidth = getOption(options, 'width', originalSize.width);\n    const srcHeight = getOption(options, 'height', originalSize.height);\n\n    let destWidth = srcWidth;\n    let destHeight = srcHeight;\n\n    if (options.mode === 'precision') {\n        return {\n            srcLeft,\n            srcTop,\n            srcWidth,\n            srcHeight,\n            destWidth,\n            destHeight\n        };\n    }\n\n    let factor;\n\n    if (srcWidth > srcHeight) {\n        factor = srcWidth / srcHeight;\n        destWidth = MAX_SIZE;\n        destHeight = Math.round(destWidth / factor);\n    } else {\n        factor = srcHeight / srcWidth;\n        destHeight = MAX_SIZE;\n        destWidth = Math.round(destHeight / factor);\n    }\n\n    if (\n        destWidth > srcWidth || destHeight > srcHeight ||\n        destWidth < MIN_SIZE || destHeight < MIN_SIZE\n    ) {\n        destWidth = srcWidth;\n        destHeight = srcHeight;\n    }\n\n    return {\n        srcLeft,\n        srcTop,\n        srcWidth,\n        srcHeight,\n        destWidth,\n        destHeight\n    };\n}\n\nfunction makeCanvas() {\n    return typeof window === 'undefined' ?\n        new OffscreenCanvas(1, 1) :\n        document.createElement('canvas');\n}\n\nconst ERROR_PREFIX = 'FastAverageColor: ';\n\nfunction outputError(options, text, details) {\n    if (!options.silent) {\n        console.error(ERROR_PREFIX + text);\n\n        if (details) {\n            console.error(details);\n        }\n    }\n}\n\nfunction getError(text) {\n    return Error(ERROR_PREFIX + text);\n}\n\nclass FastAverageColor {\n    /**\n     * Get asynchronously the average color from not loaded image.\n     *\n     * @param {string | HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | null} resource\n     * @param {FastAverageColorOptions} [options]\n     *\n     * @returns {Promise<FastAverageColorOptions>}\n     */\n    getColorAsync(resource, options) {\n        if (!resource) {\n            return Promise.reject(getError('call .getColorAsync() without resource.'));\n        }\n\n        if (typeof resource === 'string') {\n            const img = new Image();\n            img.crossOrigin = '';\n            img.src = resource;\n\n            return this._bindImageEvents(img, options);\n        } else if (resource instanceof Image && !resource.complete) {\n            return this._bindImageEvents(resource, options);\n        } else {\n            const result = this.getColor(resource, options);\n\n            return result.error ? Promise.reject(result.error) : Promise.resolve(result);\n        }\n    }\n\n    /**\n     * Get the average color from images, videos and canvas.\n     *\n     * @param {HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | null} resource\n     * @param {FastAverageColorOptions} [options]\n     *\n     * @returns {FastAverageColorResult}\n     */\n    getColor(resource, options) {\n        options = options || {};\n\n        const defaultColor = getDefaultColor(options);\n\n        if (!resource) {\n            outputError(options, 'call .getColor(null) without resource.');\n\n            return this.prepareResult(defaultColor);\n        }\n\n        const originalSize = getOriginalSize(resource);\n        const size = prepareSizeAndPosition(originalSize, options);\n\n        if (!size.srcWidth || !size.srcHeight || !size.destWidth || !size.destHeight) {\n            outputError(options, `incorrect sizes for resource \"${resource.src}\".`);\n\n            return this.prepareResult(defaultColor);\n        }\n\n        if (!this._ctx) {\n            this._canvas = makeCanvas();\n            this._ctx = this._canvas.getContext && this._canvas.getContext('2d');\n\n            if (!this._ctx) {\n                outputError(options, 'Canvas Context 2D is not supported in this browser.');\n\n                return this.prepareResult(defaultColor);\n            }\n        }\n\n        this._canvas.width = size.destWidth;\n        this._canvas.height = size.destHeight;\n\n        let value = defaultColor;\n\n        try {\n            this._ctx.clearRect(0, 0, size.destWidth, size.destHeight);\n            this._ctx.drawImage(\n                resource,\n                size.srcLeft, size.srcTop,\n                size.srcWidth, size.srcHeight,\n                0, 0,\n                size.destWidth, size.destHeight\n            );\n\n            const bitmapData = this._ctx.getImageData(0, 0, size.destWidth, size.destHeight).data;\n            value = this.getColorFromArray4(bitmapData, options);\n        } catch (e) {\n            outputError(options, `security error (CORS) for resource ${resource.src}.\\nDetails: https://developer.mozilla.org/en/docs/Web/HTML/CORS_enabled_image`, e);\n        }\n\n        return this.prepareResult(value);\n    }\n\n    /**\n     * Get the average color from a array when 1 pixel is 4 bytes.\n     *\n     * @param {number[]|Uint8Array|Uint8ClampedArray} arr\n     * @param {Object} [options]\n     * @param {string} [options.algorithm=\"sqrt\"] \"simple\", \"sqrt\" or \"dominant\"\n     * @param {number[]}  [options.defaultColor=[0, 0, 0, 0]] [red, green, blue, alpha]\n     * @param {number[]}  [options.ignoredColor] [red, green, blue, alpha]\n     * @param {number} [options.step=1]\n     *\n     * @returns {number[]} [red (0-255), green (0-255), blue (0-255), alpha (0-255)]\n     */\n    getColorFromArray4(arr, options) {\n        options = options || {};\n\n        const bytesPerPixel = 4;\n        const arrLength = arr.length;\n        const defaultColor = getDefaultColor(options);\n\n        if (arrLength < bytesPerPixel) {\n            return defaultColor;\n        }\n\n        const len = arrLength - arrLength % bytesPerPixel;\n        const step = (options.step || 1) * bytesPerPixel;\n\n        let algorithm;\n\n        switch (options.algorithm || 'sqrt') {\n            case 'simple':\n                algorithm = simpleAlgorithm;\n                break;\n            case 'sqrt':\n                algorithm = sqrtAlgorithm;\n                break;\n            case 'dominant':\n                algorithm = dominantAlgorithm;\n                break;\n            default:\n                throw getError(`${options.algorithm} is unknown algorithm.`);\n        }\n\n        return algorithm(arr, len, {\n            defaultColor,\n            ignoredColor: prepareIgnoredColor(options.ignoredColor),\n            step\n        });\n    }\n\n    /**\n     * Get color data from value ([r, g, b, a]).\n     *\n     * @param {number[]} value\n     *\n     * @returns {FastAverageColorResult}\n     */\n    prepareResult(value) {\n        const rgb = value.slice(0, 3);\n        const rgba = [].concat(rgb, value[3] / 255);\n        const isDarkColor = isDark(value);\n\n        return {\n            value,\n            rgb: 'rgb(' + rgb.join(',') + ')',\n            rgba: 'rgba(' + rgba.join(',') + ')',\n            hex: arrayToHex(rgb),\n            hexa: arrayToHex(value),\n            isDark: isDarkColor,\n            isLight: !isDarkColor\n        };\n    }\n\n    /**\n     * Destroy the instance.\n     */\n    destroy() {\n        delete this._canvas;\n        delete this._ctx;\n    }\n\n    _bindImageEvents(resource, options) {\n        return new Promise((resolve, reject) => {\n            const onload = () => {\n                unbindEvents();\n\n                const result = this.getColor(resource, options);\n\n                if (result.error) {\n                    reject(result.error);\n                } else {\n                    resolve(result);\n                }\n            };\n\n            const onerror = () => {\n                unbindEvents();\n\n                reject(getError(`Error loading image \"${resource.src}\".`));\n            };\n\n            const onabort = () => {\n                unbindEvents();\n\n                reject(getError(`Image \"${resource.src}\" loading aborted.`));\n            };\n\n            const unbindEvents = () => {\n                resource.removeEventListener('load', onload);\n                resource.removeEventListener('error', onerror);\n                resource.removeEventListener('abort', onabort);\n            };\n\n            resource.addEventListener('load', onload);\n            resource.addEventListener('error', onerror);\n            resource.addEventListener('abort', onabort);\n        });\n    }\n}\n\n/**\n * @typeof {Object} FastAverageColorOptions\n *\n * @param {number[]}  [options.defaultColor=[0, 0, 0, 0]] [red, green, blue, alpha]\n * @param {number[]}  [options.ignoredColor] [red, green, blue, alpha]\n * @param {string} [options.mode=\"speed\"] \"precision\" or \"speed\"\n * @param {string} [options.algorithm=\"sqrt\"] \"simple\", \"sqrt\" or \"dominant\"\n * @param {number} [options.step=1]\n * @param {number} [options.left=0]\n * @param {number} [options.top=0]\n * @param {number} [options.width=width of resource]\n * @param {number} [options.height=height of resource]\n * @param {boolean} [options.silent] Disable error output via console.error\n */\n\n/**\n * @typedef {Object} FastAverageColorResult\n *\n * @property {string} rgba\n * @property {string} rgb\n * @property {string} hex\n * @property {string} hexa\n * @property {number[]} value\n * @property {boolean} isDark\n * @property {boolean} isLight\n * @property {Error?} error\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FastAverageColor);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1hdmVyYWdlLWNvbG9yL2Rpc3QvaW5kZXguZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUVBQXlFO0FBQ3hGLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0VBQWdFO0FBQy9FLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxhQUFhOztBQUUvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVFQUF1RSxhQUFhO0FBQ3BGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1Q0FBdUM7QUFDdEQsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3REFBd0QsYUFBYTtBQUNyRTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxhQUFhO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBLCtEQUFlLGdCQUFnQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QtYXZlcmFnZS1jb2xvci9kaXN0L2luZGV4LmVzbS5qcz8yODMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBGYXN0IEF2ZXJhZ2UgQ29sb3IgfCDCqSAyMDIxIERlbmlzIFNlbGV6bmV2IHwgTUlUIExpY2Vuc2UgfCBodHRwczovL2dpdGh1Yi5jb20vZmFzdC1hdmVyYWdlLWNvbG9yL2Zhc3QtYXZlcmFnZS1jb2xvciAqL1xuZnVuY3Rpb24gdG9IZXgobnVtKSB7XG4gICAgY29uc3Qgc3RyID0gbnVtLnRvU3RyaW5nKDE2KTtcblxuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAxID8gJzAnICsgc3RyIDogc3RyO1xufVxuXG5mdW5jdGlvbiBhcnJheVRvSGV4KGFycikge1xuICAgIHJldHVybiAnIycgKyBhcnIubWFwKHRvSGV4KS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gaXNEYXJrKGNvbG9yKSB7XG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQUVSVCNjb2xvci1jb250cmFzdFxuICAgIGNvbnN0IHJlc3VsdCA9IChjb2xvclswXSAqIDI5OSArIGNvbG9yWzFdICogNTg3ICsgY29sb3JbMl0gKiAxMTQpIC8gMTAwMDtcblxuICAgIHJldHVybiByZXN1bHQgPCAxMjg7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVJZ25vcmVkQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yKSB7IHJldHVybiBjb2xvcjsgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY29sb3JbMF0gPT09ICdudW1iZXInID8gW2NvbG9yLnNsaWNlKCldIDogY29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjb2xvcl07XG59XG5cbmZ1bmN0aW9uIGlzSWdub3JlZENvbG9yKGRhdGEsIGluZGV4LCBpZ25vcmVkQ29sb3IpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlnbm9yZWRDb2xvci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNJZ25vcmVkQ29sb3JBc051bWJlcnMoZGF0YSwgaW5kZXgsIGlnbm9yZWRDb2xvcltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0lnbm9yZWRDb2xvckFzTnVtYmVycyhkYXRhLCBpbmRleCwgaWdub3JlZENvbG9yKSB7XG4gICAgc3dpdGNoIChpZ25vcmVkQ29sb3IubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIC8vIFtyZWQsIGdyZWVuLCBibHVlXVxuICAgICAgICAgICAgaWYgKGlzSWdub3JlZFJHQkNvbG9yKGRhdGEsIGluZGV4LCBpZ25vcmVkQ29sb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAvLyBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdXG4gICAgICAgICAgICBpZiAoaXNJZ25vcmVkUkdCQUNvbG9yKGRhdGEsIGluZGV4LCBpZ25vcmVkQ29sb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAvLyBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEsIHRocmVzaG9sZF1cbiAgICAgICAgICAgIGlmIChpc0lnbm9yZWRSR0JBQ29sb3JXaXRoVGhyZXNob2xkKGRhdGEsIGluZGV4LCBpZ25vcmVkQ29sb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJZ25vcmVkUkdCQ29sb3IoZGF0YSwgaW5kZXgsIGlnbm9yZWRDb2xvcikge1xuICAgIC8vIElnbm9yZSBpZiB0aGUgcGl4ZWwgYXJlIHRyYW5zcGFyZW50LlxuICAgIGlmIChkYXRhW2luZGV4ICsgM10gIT09IDI1NSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YVtpbmRleF0gPT09IGlnbm9yZWRDb2xvclswXSAmJlxuICAgICAgICBkYXRhW2luZGV4ICsgMV0gPT09IGlnbm9yZWRDb2xvclsxXSAmJlxuICAgICAgICBkYXRhW2luZGV4ICsgMl0gPT09IGlnbm9yZWRDb2xvclsyXVxuICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSWdub3JlZFJHQkFDb2xvcihkYXRhLCBpbmRleCwgaWdub3JlZENvbG9yKSB7XG4gICAgaWYgKGRhdGFbaW5kZXggKyAzXSAmJiBpZ25vcmVkQ29sb3JbM10pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFbaW5kZXhdID09PSBpZ25vcmVkQ29sb3JbMF0gJiZcbiAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9PT0gaWdub3JlZENvbG9yWzFdICYmXG4gICAgICAgICAgICBkYXRhW2luZGV4ICsgMl0gPT09IGlnbm9yZWRDb2xvclsyXSAmJlxuICAgICAgICAgICAgZGF0YVtpbmRleCArIDNdID09PSBpZ25vcmVkQ29sb3JbM107XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHJnYiBjb21wb25lbnRzIGlmIHRoZSBwaXhlbCBhcmUgZnVsbHkgdHJhbnNwYXJlbnQuXG4gICAgcmV0dXJuIGRhdGFbaW5kZXggKyAzXSA9PT0gaWdub3JlZENvbG9yWzNdO1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKGNvbG9yQ29tcG9uZW50LCBpZ25vcmVkQ29sb3JDb21wb25lbnQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbG9yQ29tcG9uZW50ID49IChpZ25vcmVkQ29sb3JDb21wb25lbnQgLSB2YWx1ZSkgJiZcbiAgICAgICAgY29sb3JDb21wb25lbnQgPD0gKGlnbm9yZWRDb2xvckNvbXBvbmVudCArIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNJZ25vcmVkUkdCQUNvbG9yV2l0aFRocmVzaG9sZChkYXRhLCBpbmRleCwgaWdub3JlZENvbG9yKSB7XG4gICAgY29uc3QgcmVkSWdub3JlZCA9IGlnbm9yZWRDb2xvclswXTtcbiAgICBjb25zdCBncmVlbklnbm9yZWQgPSBpZ25vcmVkQ29sb3JbMV07XG4gICAgY29uc3QgYmx1ZUlnbm9yZWQgPSBpZ25vcmVkQ29sb3JbMl07XG4gICAgY29uc3QgYWxwaGFJZ25vcmVkID0gaWdub3JlZENvbG9yWzNdO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGlnbm9yZWRDb2xvcls0XTtcbiAgICBjb25zdCBhbHBoYURhdGEgPSBkYXRhW2luZGV4ICsgM107XG5cbiAgICBjb25zdCBhbHBoYUluUmFuZ2UgPSBpblJhbmdlKGFscGhhRGF0YSwgYWxwaGFJZ25vcmVkLCB0aHJlc2hvbGQpO1xuICAgIGlmICghYWxwaGFJZ25vcmVkKSB7XG4gICAgICAgIHJldHVybiBhbHBoYUluUmFuZ2U7XG4gICAgfVxuXG4gICAgaWYgKCFhbHBoYURhdGEgJiYgYWxwaGFJblJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpblJhbmdlKGRhdGFbaW5kZXhdLCByZWRJZ25vcmVkLCB0aHJlc2hvbGQpICYmXG4gICAgICAgIGluUmFuZ2UoZGF0YVtpbmRleCArIDFdLCBncmVlbklnbm9yZWQsIHRocmVzaG9sZCkgJiZcbiAgICAgICAgaW5SYW5nZShkYXRhW2luZGV4ICsgMl0sIGJsdWVJZ25vcmVkLCB0aHJlc2hvbGQpICYmXG4gICAgICAgIGFscGhhSW5SYW5nZVxuICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRvbWluYW50QWxnb3JpdGhtKGFyciwgbGVuLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29sb3JIYXNoID0ge307XG4gICAgY29uc3QgZGl2aWRlciA9IDI0O1xuICAgIGNvbnN0IGlnbm9yZWRDb2xvciA9IG9wdGlvbnMuaWdub3JlZENvbG9yO1xuICAgIGNvbnN0IHN0ZXAgPSBvcHRpb25zLnN0ZXA7XG4gICAgbGV0IG1heCA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHJlZCA9IGFycltpXTtcbiAgICAgICAgY29uc3QgZ3JlZW4gPSBhcnJbaSArIDFdO1xuICAgICAgICBjb25zdCBibHVlID0gYXJyW2kgKyAyXTtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBhcnJbaSArIDNdO1xuXG4gICAgICAgIGlmIChpZ25vcmVkQ29sb3IgJiYgaXNJZ25vcmVkQ29sb3IoYXJyLCBpLCBpZ25vcmVkQ29sb3IpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGtleSA9IE1hdGgucm91bmQocmVkIC8gZGl2aWRlcikgKyAnLCcgK1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoZ3JlZW4gLyBkaXZpZGVyKSArICcsJyArXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZChibHVlIC8gZGl2aWRlcik7XG5cbiAgICAgICAgaWYgKGNvbG9ySGFzaFtrZXldKSB7XG4gICAgICAgICAgICBjb2xvckhhc2hba2V5XSA9IFtcbiAgICAgICAgICAgICAgICBjb2xvckhhc2hba2V5XVswXSArIHJlZCAqIGFscGhhLFxuICAgICAgICAgICAgICAgIGNvbG9ySGFzaFtrZXldWzFdICsgZ3JlZW4gKiBhbHBoYSxcbiAgICAgICAgICAgICAgICBjb2xvckhhc2hba2V5XVsyXSArIGJsdWUgKiBhbHBoYSxcbiAgICAgICAgICAgICAgICBjb2xvckhhc2hba2V5XVszXSArIGFscGhhLFxuICAgICAgICAgICAgICAgIGNvbG9ySGFzaFtrZXldWzRdICsgMVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbG9ySGFzaFtrZXldID0gW3JlZCAqIGFscGhhLCBncmVlbiAqIGFscGhhLCBibHVlICogYWxwaGEsIGFscGhhLCAxXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG1heFs0XSA8IGNvbG9ySGFzaFtrZXldWzRdKSB7XG4gICAgICAgICAgICBtYXggPSBjb2xvckhhc2hba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlZFRvdGFsID0gbWF4WzBdO1xuICAgIGNvbnN0IGdyZWVuVG90YWwgPSBtYXhbMV07XG4gICAgY29uc3QgYmx1ZVRvdGFsID0gbWF4WzJdO1xuXG4gICAgY29uc3QgYWxwaGFUb3RhbCA9IG1heFszXTtcbiAgICBjb25zdCBjb3VudCA9IG1heFs0XTtcblxuICAgIHJldHVybiBhbHBoYVRvdGFsID8gW1xuICAgICAgICBNYXRoLnJvdW5kKHJlZFRvdGFsIC8gYWxwaGFUb3RhbCksXG4gICAgICAgIE1hdGgucm91bmQoZ3JlZW5Ub3RhbCAvIGFscGhhVG90YWwpLFxuICAgICAgICBNYXRoLnJvdW5kKGJsdWVUb3RhbCAvIGFscGhhVG90YWwpLFxuICAgICAgICBNYXRoLnJvdW5kKGFscGhhVG90YWwgLyBjb3VudClcbiAgICBdIDogb3B0aW9ucy5kZWZhdWx0Q29sb3I7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUFsZ29yaXRobShhcnIsIGxlbiwgb3B0aW9ucykge1xuICAgIGxldCByZWRUb3RhbCA9IDA7XG4gICAgbGV0IGdyZWVuVG90YWwgPSAwO1xuICAgIGxldCBibHVlVG90YWwgPSAwO1xuICAgIGxldCBhbHBoYVRvdGFsID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgY29uc3QgaWdub3JlZENvbG9yID0gb3B0aW9ucy5pZ25vcmVkQ29sb3I7XG4gICAgY29uc3Qgc3RlcCA9IG9wdGlvbnMuc3RlcDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IHN0ZXApIHtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBhcnJbaSArIDNdO1xuICAgICAgICBjb25zdCByZWQgPSBhcnJbaV0gKiBhbHBoYTtcbiAgICAgICAgY29uc3QgZ3JlZW4gPSBhcnJbaSArIDFdICogYWxwaGE7XG4gICAgICAgIGNvbnN0IGJsdWUgPSBhcnJbaSArIDJdICogYWxwaGE7XG5cbiAgICAgICAgaWYgKGlnbm9yZWRDb2xvciAmJiBpc0lnbm9yZWRDb2xvcihhcnIsIGksIGlnbm9yZWRDb2xvcikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVkVG90YWwgKz0gcmVkO1xuICAgICAgICBncmVlblRvdGFsICs9IGdyZWVuO1xuICAgICAgICBibHVlVG90YWwgKz0gYmx1ZTtcbiAgICAgICAgYWxwaGFUb3RhbCArPSBhbHBoYTtcblxuICAgICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBhbHBoYVRvdGFsID8gW1xuICAgICAgICBNYXRoLnJvdW5kKHJlZFRvdGFsIC8gYWxwaGFUb3RhbCksXG4gICAgICAgIE1hdGgucm91bmQoZ3JlZW5Ub3RhbCAvIGFscGhhVG90YWwpLFxuICAgICAgICBNYXRoLnJvdW5kKGJsdWVUb3RhbCAvIGFscGhhVG90YWwpLFxuICAgICAgICBNYXRoLnJvdW5kKGFscGhhVG90YWwgLyBjb3VudClcbiAgICBdIDogb3B0aW9ucy5kZWZhdWx0Q29sb3I7XG59XG5cbmZ1bmN0aW9uIHNxcnRBbGdvcml0aG0oYXJyLCBsZW4sIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVkVG90YWwgPSAwO1xuICAgIGxldCBncmVlblRvdGFsID0gMDtcbiAgICBsZXQgYmx1ZVRvdGFsID0gMDtcbiAgICBsZXQgYWxwaGFUb3RhbCA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGNvbnN0IGlnbm9yZWRDb2xvciA9IG9wdGlvbnMuaWdub3JlZENvbG9yO1xuICAgIGNvbnN0IHN0ZXAgPSBvcHRpb25zLnN0ZXA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHJlZCA9IGFycltpXTtcbiAgICAgICAgY29uc3QgZ3JlZW4gPSBhcnJbaSArIDFdO1xuICAgICAgICBjb25zdCBibHVlID0gYXJyW2kgKyAyXTtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBhcnJbaSArIDNdO1xuXG4gICAgICAgIGlmIChpZ25vcmVkQ29sb3IgJiYgaXNJZ25vcmVkQ29sb3IoYXJyLCBpLCBpZ25vcmVkQ29sb3IpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZFRvdGFsICs9IHJlZCAqIHJlZCAqIGFscGhhO1xuICAgICAgICBncmVlblRvdGFsICs9IGdyZWVuICogZ3JlZW4gKiBhbHBoYTtcbiAgICAgICAgYmx1ZVRvdGFsICs9IGJsdWUgKiBibHVlICogYWxwaGE7XG4gICAgICAgIGFscGhhVG90YWwgKz0gYWxwaGE7XG5cbiAgICAgICAgY291bnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gYWxwaGFUb3RhbCA/IFtcbiAgICAgICAgTWF0aC5yb3VuZChNYXRoLnNxcnQocmVkVG90YWwgLyBhbHBoYVRvdGFsKSksXG4gICAgICAgIE1hdGgucm91bmQoTWF0aC5zcXJ0KGdyZWVuVG90YWwgLyBhbHBoYVRvdGFsKSksXG4gICAgICAgIE1hdGgucm91bmQoTWF0aC5zcXJ0KGJsdWVUb3RhbCAvIGFscGhhVG90YWwpKSxcbiAgICAgICAgTWF0aC5yb3VuZChhbHBoYVRvdGFsIC8gY291bnQpXG4gICAgXSA6IG9wdGlvbnMuZGVmYXVsdENvbG9yO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0Q29sb3Iob3B0aW9ucykge1xuICAgIHJldHVybiBnZXRPcHRpb24ob3B0aW9ucywgJ2RlZmF1bHRDb2xvcicsIFswLCAwLCAwLCAwXSk7XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvbihvcHRpb25zLCBuYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnNbbmFtZV0gPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogb3B0aW9uc1tuYW1lXTtcbn1cblxuY29uc3QgTUlOX1NJWkUgPSAxMDtcbmNvbnN0IE1BWF9TSVpFID0gMTAwO1xuXG5mdW5jdGlvbiBpc1N2ZyhmaWxlbmFtZSkge1xuICAgIHJldHVybiBmaWxlbmFtZS5zZWFyY2goL1xcLnN2ZyhcXD98JCkvaSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbFNpemUocmVzb3VyY2UpIHtcbiAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIGxldCB3aWR0aCA9IHJlc291cmNlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgbGV0IGhlaWdodCA9IHJlc291cmNlLm5hdHVyYWxIZWlnaHQ7XG5cbiAgICAgICAgLy8gRm9yIFNWRyBpbWFnZXMgd2l0aCBvbmx5IHZpZXdCb3ggYXR0ci5cbiAgICAgICAgaWYgKCFyZXNvdXJjZS5uYXR1cmFsV2lkdGggJiYgaXNTdmcocmVzb3VyY2Uuc3JjKSkge1xuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgPSBNQVhfU0laRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogcmVzb3VyY2UudmlkZW9XaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogcmVzb3VyY2UudmlkZW9IZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcmVzb3VyY2Uud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmVzb3VyY2UuaGVpZ2h0XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVNpemVBbmRQb3NpdGlvbihvcmlnaW5hbFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcmNMZWZ0ID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdsZWZ0JywgMCk7XG4gICAgY29uc3Qgc3JjVG9wID0gZ2V0T3B0aW9uKG9wdGlvbnMsICd0b3AnLCAwKTtcbiAgICBjb25zdCBzcmNXaWR0aCA9IGdldE9wdGlvbihvcHRpb25zLCAnd2lkdGgnLCBvcmlnaW5hbFNpemUud2lkdGgpO1xuICAgIGNvbnN0IHNyY0hlaWdodCA9IGdldE9wdGlvbihvcHRpb25zLCAnaGVpZ2h0Jywgb3JpZ2luYWxTaXplLmhlaWdodCk7XG5cbiAgICBsZXQgZGVzdFdpZHRoID0gc3JjV2lkdGg7XG4gICAgbGV0IGRlc3RIZWlnaHQgPSBzcmNIZWlnaHQ7XG5cbiAgICBpZiAob3B0aW9ucy5tb2RlID09PSAncHJlY2lzaW9uJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3JjTGVmdCxcbiAgICAgICAgICAgIHNyY1RvcCxcbiAgICAgICAgICAgIHNyY1dpZHRoLFxuICAgICAgICAgICAgc3JjSGVpZ2h0LFxuICAgICAgICAgICAgZGVzdFdpZHRoLFxuICAgICAgICAgICAgZGVzdEhlaWdodFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGxldCBmYWN0b3I7XG5cbiAgICBpZiAoc3JjV2lkdGggPiBzcmNIZWlnaHQpIHtcbiAgICAgICAgZmFjdG9yID0gc3JjV2lkdGggLyBzcmNIZWlnaHQ7XG4gICAgICAgIGRlc3RXaWR0aCA9IE1BWF9TSVpFO1xuICAgICAgICBkZXN0SGVpZ2h0ID0gTWF0aC5yb3VuZChkZXN0V2lkdGggLyBmYWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvciA9IHNyY0hlaWdodCAvIHNyY1dpZHRoO1xuICAgICAgICBkZXN0SGVpZ2h0ID0gTUFYX1NJWkU7XG4gICAgICAgIGRlc3RXaWR0aCA9IE1hdGgucm91bmQoZGVzdEhlaWdodCAvIGZhY3Rvcik7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBkZXN0V2lkdGggPiBzcmNXaWR0aCB8fCBkZXN0SGVpZ2h0ID4gc3JjSGVpZ2h0IHx8XG4gICAgICAgIGRlc3RXaWR0aCA8IE1JTl9TSVpFIHx8IGRlc3RIZWlnaHQgPCBNSU5fU0laRVxuICAgICkge1xuICAgICAgICBkZXN0V2lkdGggPSBzcmNXaWR0aDtcbiAgICAgICAgZGVzdEhlaWdodCA9IHNyY0hlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzcmNMZWZ0LFxuICAgICAgICBzcmNUb3AsXG4gICAgICAgIHNyY1dpZHRoLFxuICAgICAgICBzcmNIZWlnaHQsXG4gICAgICAgIGRlc3RXaWR0aCxcbiAgICAgICAgZGVzdEhlaWdodFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VDYW52YXMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKSA6XG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xufVxuXG5jb25zdCBFUlJPUl9QUkVGSVggPSAnRmFzdEF2ZXJhZ2VDb2xvcjogJztcblxuZnVuY3Rpb24gb3V0cHV0RXJyb3Iob3B0aW9ucywgdGV4dCwgZGV0YWlscykge1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihFUlJPUl9QUkVGSVggKyB0ZXh0KTtcblxuICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihkZXRhaWxzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RXJyb3IodGV4dCkge1xuICAgIHJldHVybiBFcnJvcihFUlJPUl9QUkVGSVggKyB0ZXh0KTtcbn1cblxuY2xhc3MgRmFzdEF2ZXJhZ2VDb2xvciB7XG4gICAgLyoqXG4gICAgICogR2V0IGFzeW5jaHJvbm91c2x5IHRoZSBhdmVyYWdlIGNvbG9yIGZyb20gbm90IGxvYWRlZCBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGx9IHJlc291cmNlXG4gICAgICogQHBhcmFtIHtGYXN0QXZlcmFnZUNvbG9yT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGYXN0QXZlcmFnZUNvbG9yT3B0aW9ucz59XG4gICAgICovXG4gICAgZ2V0Q29sb3JBc3luYyhyZXNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZ2V0RXJyb3IoJ2NhbGwgLmdldENvbG9yQXN5bmMoKSB3aXRob3V0IHJlc291cmNlLicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9ICcnO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHJlc291cmNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluZEltYWdlRXZlbnRzKGltZywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZSAmJiAhcmVzb3VyY2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iaW5kSW1hZ2VFdmVudHMocmVzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRDb2xvcihyZXNvdXJjZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZXJyb3IgPyBQcm9taXNlLnJlamVjdChyZXN1bHQuZXJyb3IpIDogUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGF2ZXJhZ2UgY29sb3IgZnJvbSBpbWFnZXMsIHZpZGVvcyBhbmQgY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbH0gcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ge0Zhc3RBdmVyYWdlQ29sb3JPcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGYXN0QXZlcmFnZUNvbG9yUmVzdWx0fVxuICAgICAqL1xuICAgIGdldENvbG9yKHJlc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGdldERlZmF1bHRDb2xvcihvcHRpb25zKTtcblxuICAgICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgICAgICBvdXRwdXRFcnJvcihvcHRpb25zLCAnY2FsbCAuZ2V0Q29sb3IobnVsbCkgd2l0aG91dCByZXNvdXJjZS4nKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChkZWZhdWx0Q29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTaXplID0gZ2V0T3JpZ2luYWxTaXplKHJlc291cmNlKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHByZXBhcmVTaXplQW5kUG9zaXRpb24ob3JpZ2luYWxTaXplLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoIXNpemUuc3JjV2lkdGggfHwgIXNpemUuc3JjSGVpZ2h0IHx8ICFzaXplLmRlc3RXaWR0aCB8fCAhc2l6ZS5kZXN0SGVpZ2h0KSB7XG4gICAgICAgICAgICBvdXRwdXRFcnJvcihvcHRpb25zLCBgaW5jb3JyZWN0IHNpemVzIGZvciByZXNvdXJjZSBcIiR7cmVzb3VyY2Uuc3JjfVwiLmApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KGRlZmF1bHRDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2N0eCkge1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gbWFrZUNhbnZhcygpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQgJiYgdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fY3R4KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0RXJyb3Iob3B0aW9ucywgJ0NhbnZhcyBDb250ZXh0IDJEIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChkZWZhdWx0Q29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gc2l6ZS5kZXN0V2lkdGg7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBzaXplLmRlc3RIZWlnaHQ7XG5cbiAgICAgICAgbGV0IHZhbHVlID0gZGVmYXVsdENvbG9yO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHNpemUuZGVzdFdpZHRoLCBzaXplLmRlc3RIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICByZXNvdXJjZSxcbiAgICAgICAgICAgICAgICBzaXplLnNyY0xlZnQsIHNpemUuc3JjVG9wLFxuICAgICAgICAgICAgICAgIHNpemUuc3JjV2lkdGgsIHNpemUuc3JjSGVpZ2h0LFxuICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgc2l6ZS5kZXN0V2lkdGgsIHNpemUuZGVzdEhlaWdodFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgYml0bWFwRGF0YSA9IHRoaXMuX2N0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZS5kZXN0V2lkdGgsIHNpemUuZGVzdEhlaWdodCkuZGF0YTtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRDb2xvckZyb21BcnJheTQoYml0bWFwRGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG91dHB1dEVycm9yKG9wdGlvbnMsIGBzZWN1cml0eSBlcnJvciAoQ09SUykgZm9yIHJlc291cmNlICR7cmVzb3VyY2Uuc3JjfS5cXG5EZXRhaWxzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZWAsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhdmVyYWdlIGNvbG9yIGZyb20gYSBhcnJheSB3aGVuIDEgcGl4ZWwgaXMgNCBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118VWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hbGdvcml0aG09XCJzcXJ0XCJdIFwic2ltcGxlXCIsIFwic3FydFwiIG9yIFwiZG9taW5hbnRcIlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119ICBbb3B0aW9ucy5kZWZhdWx0Q29sb3I9WzAsIDAsIDAsIDBdXSBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gIFtvcHRpb25zLmlnbm9yZWRDb2xvcl0gW3JlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGVwPTFdXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFtyZWQgKDAtMjU1KSwgZ3JlZW4gKDAtMjU1KSwgYmx1ZSAoMC0yNTUpLCBhbHBoYSAoMC0yNTUpXVxuICAgICAqL1xuICAgIGdldENvbG9yRnJvbUFycmF5NChhcnIsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgY29uc3QgYnl0ZXNQZXJQaXhlbCA9IDQ7XG4gICAgICAgIGNvbnN0IGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGdldERlZmF1bHRDb2xvcihvcHRpb25zKTtcblxuICAgICAgICBpZiAoYXJyTGVuZ3RoIDwgYnl0ZXNQZXJQaXhlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxlbiA9IGFyckxlbmd0aCAtIGFyckxlbmd0aCAlIGJ5dGVzUGVyUGl4ZWw7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSAob3B0aW9ucy5zdGVwIHx8IDEpICogYnl0ZXNQZXJQaXhlbDtcblxuICAgICAgICBsZXQgYWxnb3JpdGhtO1xuXG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0gfHwgJ3NxcnQnKSB7XG4gICAgICAgICAgICBjYXNlICdzaW1wbGUnOlxuICAgICAgICAgICAgICAgIGFsZ29yaXRobSA9IHNpbXBsZUFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NxcnQnOlxuICAgICAgICAgICAgICAgIGFsZ29yaXRobSA9IHNxcnRBbGdvcml0aG07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb21pbmFudCc6XG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtID0gZG9taW5hbnRBbGdvcml0aG07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IGdldEVycm9yKGAke29wdGlvbnMuYWxnb3JpdGhtfSBpcyB1bmtub3duIGFsZ29yaXRobS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbGdvcml0aG0oYXJyLCBsZW4sIHtcbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcixcbiAgICAgICAgICAgIGlnbm9yZWRDb2xvcjogcHJlcGFyZUlnbm9yZWRDb2xvcihvcHRpb25zLmlnbm9yZWRDb2xvciksXG4gICAgICAgICAgICBzdGVwXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjb2xvciBkYXRhIGZyb20gdmFsdWUgKFtyLCBnLCBiLCBhXSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Zhc3RBdmVyYWdlQ29sb3JSZXN1bHR9XG4gICAgICovXG4gICAgcHJlcGFyZVJlc3VsdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCByZ2IgPSB2YWx1ZS5zbGljZSgwLCAzKTtcbiAgICAgICAgY29uc3QgcmdiYSA9IFtdLmNvbmNhdChyZ2IsIHZhbHVlWzNdIC8gMjU1KTtcbiAgICAgICAgY29uc3QgaXNEYXJrQ29sb3IgPSBpc0RhcmsodmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHJnYjogJ3JnYignICsgcmdiLmpvaW4oJywnKSArICcpJyxcbiAgICAgICAgICAgIHJnYmE6ICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJyxcbiAgICAgICAgICAgIGhleDogYXJyYXlUb0hleChyZ2IpLFxuICAgICAgICAgICAgaGV4YTogYXJyYXlUb0hleCh2YWx1ZSksXG4gICAgICAgICAgICBpc0Rhcms6IGlzRGFya0NvbG9yLFxuICAgICAgICAgICAgaXNMaWdodDogIWlzRGFya0NvbG9yXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NhbnZhcztcbiAgICAgICAgZGVsZXRlIHRoaXMuX2N0eDtcbiAgICB9XG5cbiAgICBfYmluZEltYWdlRXZlbnRzKHJlc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5iaW5kRXZlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldENvbG9yKHJlc291cmNlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IG9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5iaW5kRXZlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICByZWplY3QoZ2V0RXJyb3IoYEVycm9yIGxvYWRpbmcgaW1hZ2UgXCIke3Jlc291cmNlLnNyY31cIi5gKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBvbmFib3J0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuYmluZEV2ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgcmVqZWN0KGdldEVycm9yKGBJbWFnZSBcIiR7cmVzb3VyY2Uuc3JjfVwiIGxvYWRpbmcgYWJvcnRlZC5gKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCB1bmJpbmRFdmVudHMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9ubG9hZCk7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9ubG9hZCk7XG4gICAgICAgICAgICByZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbmFib3J0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEB0eXBlb2Yge09iamVjdH0gRmFzdEF2ZXJhZ2VDb2xvck9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSAgW29wdGlvbnMuZGVmYXVsdENvbG9yPVswLCAwLCAwLCAwXV0gW3JlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXVxuICogQHBhcmFtIHtudW1iZXJbXX0gIFtvcHRpb25zLmlnbm9yZWRDb2xvcl0gW3JlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1vZGU9XCJzcGVlZFwiXSBcInByZWNpc2lvblwiIG9yIFwic3BlZWRcIlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFsZ29yaXRobT1cInNxcnRcIl0gXCJzaW1wbGVcIiwgXCJzcXJ0XCIgb3IgXCJkb21pbmFudFwiXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RlcD0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlZnQ9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50b3A9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aD13aWR0aCBvZiByZXNvdXJjZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9aGVpZ2h0IG9mIHJlc291cmNlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zaWxlbnRdIERpc2FibGUgZXJyb3Igb3V0cHV0IHZpYSBjb25zb2xlLmVycm9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGYXN0QXZlcmFnZUNvbG9yUmVzdWx0XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJnYmFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZ2JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoZXhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoZXhhXG4gKiBAcHJvcGVydHkge251bWJlcltdfSB2YWx1ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0RhcmtcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNMaWdodFxuICogQHByb3BlcnR5IHtFcnJvcj99IGVycm9yXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgRmFzdEF2ZXJhZ2VDb2xvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fast-average-color/dist/index.esm.js\n");

/***/ }),

/***/ "./resources/css/main.css":
/*!********************************!*\
  !*** ./resources/css/main.css ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvY3NzL21haW4uY3NzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9jc3MvbWFpbi5jc3M/MDc2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/css/main.css\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	!function() {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = function(result, chunkIds, fn, priority) {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var chunkIds = deferred[i][0];
/******/ 				var fn = deferred[i][1];
/******/ 				var priority = deferred[i][2];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/spotifynt": 0,
/******/ 			"css/main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			for(moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) var result = runtime(__webpack_require__);
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/main"], function() { return __webpack_require__("./resources/js/spotifynt.js"); })
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/main"], function() { return __webpack_require__("./resources/css/main.css"); })
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;